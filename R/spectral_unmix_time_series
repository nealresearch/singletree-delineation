# Load required libraries
library(raster)
library(e1071)
library(foreach)
library(parallel)
library(doParallel)
library(RStoolbox)
library(randomForest)

options(digits = 15)

# Number of logical processors (default behavior)
num_logical_cores <- detectCores()
cat("Number of logical processors:", num_logical_cores, "\n")

# Use one less than total cores
cl <- makeCluster(24)
registerDoParallel(cl)

# Define the function to get pixel values from a raster at specific coordinates
getPixelValues <- function(raster, x, y) {
  # Check if input is a raster stack or brick
  if (!is(raster, "RasterStack") && !is(raster, "RasterBrick")) {
    stop("Input must be a RasterStack or RasterBrick")
  }
  # Extract values
  values <- extract(raster, cbind(x, y))
  return(values)
}

spectral_interpolate <- function(raster, band_count) {
  # Find indices of NAs
  na_index <- which(is.na(raster), arr.ind = TRUE)
  
  # Extract row and column indices
  rows <- na_index[, 1]
  cols <- na_index[, 2]
  
  # Prepare shifted indices
  cols_1 <- cols + band_count
  cols_2 <- cols - band_count
  
  # Ensure indices are within bounds
  valid_cols_1 <- cols_1 > 0 & cols_1 <= ncol(raster)
  valid_cols_2 <- cols_2 > 0 & cols_2 <= ncol(raster)
  
  # Fetch values for valid indices
  val1 <- ifelse(valid_cols_1, raster[cbind(rows[valid_cols_1], cols_1[valid_cols_1])], NA)
  val2 <- ifelse(valid_cols_2, raster[cbind(rows[valid_cols_2], cols_2[valid_cols_2])], NA)
  
  # Calculate mean values
  mean_vals <- rowMeans(cbind(val1, val2), na.rm = TRUE)
  
  # Assign the interpolated values back to the raster
  raster[cbind(rows, cols)] <- mean_vals
  
  return(raster)
}


x_coords <- c(605884.35241388, 597015.27041402, 605844.62606236, 603774.28656804, 607434.03734735, 609344.77338910, 602124.81339392, 607954.57084150, 606095.39666017,
              604124.70977756, 605104.54067884, 606224.56587683, 604344.85966594, 603704.95771947, 605354.74183253, 601594.67715700, 603455.04413186, 605704.91914485,
              603934.93829377, 607184.99571110, 601544.81117353, 605774.21984302, 602834.89291018, 608434.99654031, 603804.82767571, 601997.45176002, 605844.00057853,
              601343.96007151, 602025.02029399, 600955.18869249, 601385.30020858, 605444.84586968, 607914.89023268, 602024.71019722, 604325.42330900, 605524.06270606,
              603995.13082208, 604524.86683747, 600944.80810616, 601545.37358462, 605214.61848969, 606084.86966286, 603794.85026818, 605335.55162396, 604304.38362382,
              605774.28906632, 600125.20448450, 605564.81619286, 602014.48674017, 606704.94364340, 601514.94141965, 603804.47109654, 605254.88785562, 600594.57098086,
              602894.57743594, 603505.16630111, 607614.96905017, 602155.86598629, 603484.57035356, 603714.52026222, 603914.85641389, 605884.68866015, 604153.87142431,
              604095.42293653, 604504.37753244, 608805.08644681, 602154.98347404, 605374.65080647, 604214.75961462, 603944.95083433, 603504.38658923, 603554.64218187,
              605555.11174017, 606594.53520062, 607494.50647028, 605994.50201132, 600815.13073052, 602414.73516515, 606824.74821216, 605514.67297378, 608784.87147931,
              605815.46074196, 605914.42621424, 608694.83478299, 605894.71524881, 607724.98193534, 604124.55308533, 607205.29890495, 603644.73790031, 605223.53060541,
              603234.98268027, 607515.77780468, 608164.62454239, 607635.15820545, 603284.83276058, 603904.56008771)

y_coords <- c(5794904.90526522, 5784795.27742394, 5784395.27011304, 5794415.18098868, 5787455.68545425, 5791535.12023019, 5796505.58514599, 5789565.89635590, 5791905.90097722,
              5795713.66478177, 5784703.75372495, 5784615.86404430, 5796745.92421278, 5790735.03360869, 5785105.35503072, 5795296.35366749, 5790545.91561108, 5794325.09599137,
              5795955.07904738, 5787075.42469928, 5786475.51631602, 5788845.13564746, 5790415.13268498, 5792294.81865189, 5787834.97731442, 5793005.55580780, 5791785.56497453,
              5790825.02979738, 5793385.96403187, 5785845.49756323, 5790805.24061383, 5797575.55745169, 5787226.65458200, 5796195.05347378, 5787544.49772795, 5792296.23977339,
              5796835.99326819, 5785945.83888284, 5786545.31993459, 5795256.02931317, 5789981.95943597, 5792815.55087392, 5787845.15047676, 5789235.00819428, 5792235.62237172,
              5788985.15105885, 5795175.63878127, 5789505.26258405, 5795745.40096096, 5788504.98923572, 5786514.68887557, 5790115.15755363, 5788334.93847815, 5793575.70545686,
              5787504.87047453, 5790495.12300083, 5790685.59478960, 5795375.91999403, 5791495.97073622, 5784015.70694278, 5794315.80285308, 5788675.15152941, 5795914.82326430,
              5795665.41734951, 5794055.48500819, 5791034.81997643, 5795385.82133734, 5797145.52899016, 5792405.51507242, 5795955.28158522, 5791275.36443168, 5790845.83591439,
              5787795.44100119, 5797735.61121927, 5787925.37410835, 5791765.25067044, 5796256.04318109, 5794505.97117331, 5792026.16675357, 5798535.14786945, 5791025.56202057,
              5792105.32348778, 5798215.41734952, 5791104.85657574, 5794885.52964838, 5793786.42077621, 5790065.30746914, 5796085.88442340, 5791655.35340665, 5792085.63900867,
              5793635.35365762, 5791984.93044173, 5787445.06533302, 5794745.99085592, 5792825.13227703, 5790375.32117592)


# Class labels for each coordinate pair
classes <- c("grass", "buildings", "trees")

max_length <- (length(x_coords) / length(classes))
raster_files <- list.files("//home//nilraj.shrestha//R//umixing//Braunschwieg_sen2//", full.names = TRUE)
number_sample <- 100

# 3. Parallel loop over each file
all_data_list <- foreach(rfile = raster_files, .combine = rbind, .packages = c("raster")) %dopar% {
  
  current_raster <- stack(rfile)
  # Keep only the first 10 bands
  current_raster <- current_raster[[1:10]]
  
  # Pre-allocate a matrix to hold the results
  num_bands <- nlayers(current_raster)
  result_matrix <- matrix(NA, nrow = length(x_coords), ncol = num_bands)
  
  # Populate the matrix with pixel values
  for (i in 1:length(x_coords)) {
    # Get pixel values at specified coordinates
    pixel_values <- getPixelValues(current_raster, x_coords[i], y_coords[i])
    # Store the values in the corresponding row of the matrix
    result_matrix[i, ] <- pixel_values
  }
  # Convert the result matrix to a dataframe
  result_df <- as.data.frame(result_matrix)
  
  # Naming the columns as Band1, Band2, ..., BandN
  names(result_df) <- paste0("Band", 1:num_bands)
  result_df$class <- classes
  
  grass <- subset(result_df, class == "grass")
  row.names(grass) <- NULL
  
  building <- subset(result_df, class == "buildings")
  row.names(building) <- NULL
  
  trees <- subset(result_df, class == "trees")
  row.names(trees) <- NULL
  
  values <- seq(0, 1, 0.1)
  combinations <- list()
  count <- 1
  for (x in values) {
    for (y in values) {
      z <- round(1 - (x + y), digits = 1)
      if (z >= 0 && z <= 1) { # Ensure z is within the range
        combinations[[count]] <- c(x, y, z)
        count <- count + 1
      }
    }
  }
  
  fraction_comb <- do.call(rbind, combinations)
  
  grass_image_list <- list()
  building_image_list <- list()
  trees_image_list <- list()
  
  random_number <- function(){
    number <- floor(runif(3, min=1, max=max_length))
    return (number)
  }
  
  build_dataframe <- function(end_member1, end_member2, end_member3, f_comb){
    
    data_f <- data.frame()
    #loop throught each fraction in combination list
    for (i in seq_len(nrow(f_comb))){
      sample_data <- data.frame()
      # pick 100 random sample for each fraction
      for (j in seq_len(number_sample)){
        randn <- random_number()
        first <- randn[1]
        second <- randn[2]
        third <- randn[3]
        # loop through each band
        for (z in seq_len(10)){
          value <- as.numeric(end_member1[first, z]) * f_comb[i,][1] + as.numeric(end_member2[second, z]) * f_comb[i,][2] + as.numeric(end_member3[third, z]) * f_comb[i,][3]
          sample_data[1, paste0("Band", z)] <- value
        }
        sample_data$MixtureFraction <-  f_comb[i,][1]
        data_f <- rbind(data_f, sample_data)
      }
    }
    return (data_f)
  }
  # Create data frame and replace the mixture fraction
  data_g <- build_dataframe(grass, building, trees, fraction_comb)
  data_b <- data_g
  vector_building <- rep(fraction_comb[, 2], each = number_sample)
  data_b$MixtureFraction <- vector_building
  data_t <- data_g
  vector_trees <- rep(fraction_comb[, 3], each = number_sample)
  data_t$MixtureFraction <- vector_trees
  
  return(list(
    grass    = data_g,
    building = data_b,
    trees    = data_t
  ))
}

my_results <- all_data_list
#extract the tree dataframes and merge it into one
grass_list <- lapply(seq_len(nrow(my_results)), function(i) {
  my_results[i, "grass"][[1]]  
})
#remove MixtureFraction as we only need one column
grass_list_bands <- lapply(grass_list, function(df) {
  df[, !names(df) %in% "MixtureFraction"] 
})
# stack the dataframe column wise to create a timeseries
data_g <- do.call(cbind, grass_list_bands)
data_g <- spectral_interpolate(data_g, 10)

grass_fraction <- grass_list[[1]]$MixtureFraction
data_g$MixtureFraction <- grass_fraction

#Same idea as above for building.
#extract the building dataframes
building_list <- lapply(seq_len(nrow(my_results)), function(i) {
  my_results[i, "building"][[1]]  # This is a data frame
})
building_list_bands <- lapply(building_list, function(df1) {
  df1[, !names(df1) %in% "MixtureFraction"]  
})
data_b <- do.call(cbind, building_list_bands)
data_b <- spectral_interpolate(data_b, 10)
building_fraction <- building_list[[1]]$MixtureFraction
data_b$MixtureFraction <- building_fraction


#Same idea as above for Trees
tree_list <- lapply(seq_len(nrow(my_results)), function(i) {
  my_results[i, "trees"][[1]]  # This is a data frame
})
tree_list_bands <- lapply(tree_list, function(df2) {
  df2[, !names(df2) %in% "MixtureFraction"]  
})
data_t <- do.call(cbind, tree_list_bands)
data_t <- spectral_interpolate(data_t, 10)
tree_fraction <- tree_list[[1]]$MixtureFraction
data_t$MixtureFraction <- tree_fraction

stopCluster(cl)

# Define feature columns
feature_columns <- paste0("Band", 1:10)

# Function to train and evaluate a Random Forest model
rf_model <- function(data, feature_columns, target_column = "MixtureFraction") {
  # Ensure target variable is numeric
  data[[target_column]] <- as.numeric(data[[target_column]])
  
  # Split data into training and testing sets
  set.seed(123)  # For reproducibility
  train_indices <- sample(1:nrow(data), 0.9 * nrow(data))
  train_data <- data[train_indices, ]
  test_data <- data[-train_indices, ]
  
  # Train the Random Forest model
  rf_model <- randomForest(
    x = train_data[, feature_columns],
    y = train_data[[target_column]],
    ntree = 500,
    mtry = 10,
    sampsize = 5000,
    importance = TRUE
  )
  
  # Evaluate the model on test data
  predictions <- predict(rf_model, test_data[, feature_columns])
  actual <- test_data[[target_column]]
  
  # Calculate Mean Squared Error (MSE)
  mse <- mean((predictions - actual)^2)
  rmse <- sqrt(mse)
  cat("Model RMSE:", rmse, "\n")
  
  # Return the trained model
  return(rf_model)
}
# Function to predict mixture fractions using the Random Forest model
predict_mixture_fraction <- function(model, sentinel_image, feature_columns) {
  # Ensure band names match the model features
  names(sentinel_image) <- feature_columns
  # Predict the mixture fraction
  predicted_values <- predict(model, as.data.frame(getValues(sentinel_image)))
  # Create a raster to hold the predicted value
  results <- setValues(raster(sentinel_image), predicted_values)
  return(results)
}
# 1) Get all file paths
all_images <- list.files("//home//nilraj.shrestha//R//umixing//test_data//time_series//", pattern = "*.tif$", full.names = TRUE)

process_one_image <- function(img_path, feature_columns, data_g, data_b, data_t) {
   # Load the image
    sentinel_image <- stack(img_path)
    sentinel_image <- sentinel_image[[1:10]]
    names(sentinel_image) <- feature_columns
    sentinel_image[is.na(sentinel_image)] <- 0
       
      # Train each model (or load trained models if already trained)
      model_g <- rf_model(data_g, feature_columns)
      model_b <- rf_model(data_b, feature_columns)
      model_t <- rf_model(data_t, feature_columns)
         
        # Predict fraction images
        predicted_mixture_g <- predict_mixture_fraction(model_g, sentinel_image, feature_columns)
        predicted_mixture_b <- predict_mixture_fraction(model_b, sentinel_image, feature_columns)
        predicted_mixture_t <- predict_mixture_fraction(model_t, sentinel_image, feature_columns)
           
          #Combine and normalize
          predicted_stack <- stack(predicted_mixture_g, predicted_mixture_b, predicted_mixture_t)
          names(predicted_stack) <- c("GrassFraction", "BuildingFraction", "TreeFraction")
          normalized_stack <- calc(predicted_stack, fun = function(x) {
                 s <- sum(x)
                 if(s == 0) rep(0, length(x)) else x / s
               })
             return(normalized_stack)
           }
# 3) Loop through images
predictions_list <- lapply(all_images, process_one_image, feature_columns, data_g, data_b, data_t)
# Define the output directory where you want to save the rasters
output_dir <- "//home//nilraj.shrestha//R//umixing//test_result//"

# Loop through the list and save each raster
for (i in seq_along(predictions_list)) {
  # Define a file name for each raster (e.g., prediction_1.tif, prediction_2.tif, etc.)
  file_name <- paste0(output_dir, "/prediction_", i, ".tif")
  
  # Save the raster
  writeRaster(predictions_list[[i]], filename = file_name, format = "GTiff", overwrite = TRUE)
}

